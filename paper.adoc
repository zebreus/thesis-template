:doctype: book
:imagesdir: images
:stylesheet: paper.css
// Disable generating an update label at the bottom of the doc.
:last-update-label!:
// Setup highlight.js to use a local version with a local stylesheet
:source-highlighter: highlight.js
:highlightjs-theme: thesis
:highlightjsdir: libraries/highlightjs
// Enable rendering mathequations
:stem:
// Generate table of contents at the toc macro
// Also disableing section numbers for now, as we only start numbering after the toc. See the macros there
:toc: macro
:toclevels: 3
:sectanchors:
// Disable title page
// We will build the title page manually for maximum flexibility
:notitle:
:title-page: false
// Refer to things like "Figure 1" instead of by their name
:xrefstyle: short
// Prefetch and inline diagrams with kroki but not in vscode
ifndef::env-vscode[]
:kroki-fetch-diagram: true
:kroki-default-options: inline
endif::env-vscode[]

image::logo_hda.svg[role=logo]

[.university.text-center]
Darmstadt University of Applied Sciences

[.faculty.text-center]
Faculty of Computer Science

[discrete#main-title]
= Is high-level synthesis from Rust possible using existing tools?

[.description.text-center]
Submitted in partial fulfillment of the requirements for the degree of +
Bachelor of Science (B.Sc.)

[.presented-by.text-center]
by +
*Zebreus* +
[small]+Matriculation number: XXXXXX+ +


[.other-people]
First Examiner:: Prof. Dr. Some Person
Second Examiner:: Prof. Dr. Another Person

<<<



<<<

[discrete]
== Declaration

If you are writing a thesis you probably need this bit to confirm that you wrote it all by yourself. This template adds the `signature-required` CSS class which add a nice line where you can write your name.

If you are not writing a thesis, just delete this whole section.

_Darmstadt, 5.7.2023_

[.signature-required]
Zebreus

<<<

[discrete]
== Abstract
// A summary of the contents in English of about one page. The following
// points should be addressed in particular:

// * Motivation: Why did this work come about? Why is the topic of the
// work interesting (for the general public)? The motivation should be
// abstracted as far as possible from the specific tasks that may be given
// by a company.
// * Content: What is the content of this thesis? What exactly is covered in
// the thesis? The methodology and working method should be briefly
// discussed here.
// * Results: What are the results of this work? A brief overview of the
// Most actual results as a teaser to read the complete thesis.


// Generated with chatgpt
This document presents the Asciidoctor.js thesis template, which offers a versatile and easily understandable alternative to traditional typesetting systems for scientific writing. The template leverages the flexibility of web technologies, allowing seamless design modifications and rendering both PDF and website versions of the thesis. The source document structure resembles markdown, enhancing its readability. This abstract provides an overview of the template's benefits, getting started instructions, toolchain details, customization options using JavaScript, integration of source code listings and syntax highlighting, philosophical considerations behind the design decisions, and a comprehensive guide to using the template's features for scientific writing. Overall, the Asciidoctor.js thesis template provides a user-friendly and efficient approach for creating scientific theses, offering enhanced readability and ease of customization compared to traditional typesetting systems.

// The table of contents gets inserted here.
toc::[]

// This generates the tables for listings, figures, and tables
// If you do not need all of them, just modiy that file.

<<<

// Start with section and part numbering
:part-signifier: Part
:sectnums:
:listing-caption: Listing
:partnums:

// Main part starts here
[.reset-pages]
= Thesis

== Introduction

The popularity of the Rust programming language is rising, and it is one of the most admired programming languages <<Sta16>> <<Sta20>> <<Sta23>> <<Bug22>>. It integrates modern tooling like standardized dependency management, testing, documentation generation, formatting, and building. In the future, adoption will probably increase further, and it could replace {cpp} as the most common systems programming language <<Bug22>>.
Rust also provides benefits in domains other than systems programming. It has been shown that Rust can be used for other fields such as GPU programming, web development, or logic programming <<Sah22>> <<Byc22>> <<Kyr22>>. These fields profit from some of the benefits of Rust, like guaranteed memory safety and improved productivity  <<Bug22>> <<Cos19>>.

This paper explores how Rust can be used in FPGA firmware development. Usually, FPGA firmware is developed in a hardware description language (HDL) such as Verilog or VHDL. In these languages, the programmer has to describe the hardware in detail. This low-level approach can lead to efficient designs but is quite time-consuming <<Mil20>>. The RustHDL project facilitates expressing hardware descriptions in Rust similar to traditional HDLs <<Smi21>>. In addition to manually designing hardware in an HDL, it is also possible to use high-level synthesis (HLS) to generate hardware descriptions in HDLs from an algorithmic description written in high-level programming languages. Typically systems programming languages are used for writing these specifications. This increases productivity at the cost of slightly less optimized designs <<Mil20>>. There are multiple HLS tools available that can synthesize HDL descriptions from {cpp} code. Some of these tools are based on the LLVM compiler infrastructure <<Nan16>>. The only previous report on using Rust as an HLS language focuses on a limited subset of Rust and its formal verification <<Har22>>. 

// As Rust is also based on LLVM, it can be used with these tools too. 

// To determine the feasibility of utilizing Rust as a source language for High-Level Synthesis (HLS).
An investigation to identify HLS tools compatible with Rust was conducted. A modular approach was developed to seamlessly integrate HLS tools with RustHDL. By employing this approach, a proof-of-concept integration with the PandA Bambu HLS framework was achieved, demonstrating the feasibility of using Rust as a source language for HLS. The performance of designs generated from various algorithms was compared with that of designs generated from algorithmically equivalent {cpp} code. The evaluation showed that, in most cases, the Rust-based workflow produced designs with similar characteristics to those derived from {cpp}-based workflows.

// CAUTION: Rework the start of this section

== Using figures

All chart types except for vega-lite should just be used as asciidoctor-kroki charts. You can reference your chart in the text lik <<sample-nomnoml-chart>>, by giving it an id, in this case `sample-nomnoml-chart`.

.Sample nomnoml chart
[nomnoml,id=sample-nomnoml-chart]
....
[<actor>Jolly;Sailor]
[Jolly;Sailor]->[Pirate]
[Jolly;Sailor]->[rum]

[Pirate|
  [beard]--[parrot]
  [beard]-:>[foul mouth]
]
[Pirate]-> *[rum|tastiness: int|swig()]
[<abstract>Marauder]<:--[Pirate]

[<table>mischief| bawl | sing || yell | drink ]
[Pirate] - 0..7[mischief]

#gutter: 10
#lineWidth: 1.25
#stroke: #000000
#font: Spectral
#fill: #f7f8f7; #ffffff; #f7f8f7; #ffffff; #f7f8f7; #ffffff
....

.Source for the section above
[source,asciidoc]
----
All chart types except for vega-lite should just be used as asciidoctor-kroki charts. You can reference your chart in the text lik <<sample-nomnoml-chart>>, by giving it an id, in this case `sample-nomnoml-chart`.

.Sample nomnoml chart
[nomnoml,id=sample-nomnoml-chart]
....
[<actor>Jolly;Sailor]
[Jolly;Sailor]->[Pirate]
[Jolly;Sailor]->[rum]

[Pirate|
  [beard]--[parrot]
  [beard]-:>[foul mouth]
]
[Pirate]-> *[rum|tastiness: int|swig()]
[<abstract>Marauder]<:--[Pirate]

[<table>mischief| bawl | sing || yell | drink ]
[Pirate] - 0..7[mischief]

#gutter: 10
#lineWidth: 1.25
#stroke: #000000
#font: Spectral
#fill: #f7f8f7; #ffffff; #f7f8f7; #ffffff; #f7f8f7; #ffffff
....
----

.Sample wavedrom chart
[wavedrom,id=sample-wavedrom-chart]
....
include::assets/keccak_clang_speed.wavejson.json[]
....

.Source for the wavedrom chart
[source,asciidoc]
----
.Sample wavedrom chart
[wavedrom,id=sample-wavedrom-chart]
....
\include::assets/keccak_clang_speed.wavejson.json[]
....
----

To make the chart extend over the margins of the page, add a `slightly-oversized`, `oversized` or `completly-oversized` to the chart.

.Source for the section above
.Sample graphviz graph
[graphviz.slightly-oversized,id=minmax-speed-cfg,width=570px]
....
include::assets/minmax_speed_control_flow.dot[]
....

[source,asciidoc]
----
.Sample graphviz graph
[graphviz.slightly-oversized,id=minmax-speed-cfg,width=570px]
....
\include::assets/minmax_speed_control_flow.dot[]
....
----

=== vega-lite

Vega-lite is the preferred way to display any data-driven charts. You use the included `vega-chart.adoc` script to include vega-lite charts. It detects if the document is currently built for a browser or as a PDF. If the document is built for a browser, it will include the chart directly via the vega javascript library. That way the chart supports tooltips and other interactive features.

[source.completly-oversized,asciidoc,subs=attributes]
----
.Sample vega-lite chart
:chart-id: id=minmax-area
:vega-lite-filename: processed-assets/minmax_overview_area.vl.json
\include::scripts/vega-chart.adoc[]
----

.Sample vega-lite chart
:chart-id: id=minmax-area
:vega-lite-filename: processed-assets/minmax_overview_area.vl.json
include::scripts/vega-chart.adoc[]

== Using source listings

Asciidoc also supports source listings. A short verilog listing is shown in <<short-verilog-listing>>.

.Short Verilog listing
[source#short-verilog-listing,verilog]
----
module Blinker (input clock, output blinker);
  reg [6:0] counter = 0;
  reg state = 0;
  always @(posedge clock) begin
    counter <= counter + 1;
    if (counter == 9) begin
      state   <= ~state;
      counter <= 0;
    end
  end
  assign blinker = state;
endmodule
----

<<long-rust-listing>> shows a long Rust listing. This template has a `.linenums` class that can be added to code listings to enable line numbers. The normal asciidoc `linenums` attribute is not supported.

.Long rust listing with line numbers
[source#long-rust-listing.linenums,rust]
----
include::assets/long_rust_listing.rs[tag=function]
----

Your code should be not wider than 80 characters. If it is try using the `oversized` classes to avoid unnecessary line breaks.

== Using tables

Asciidoc supports tables. A simple table is shown in <<somewhat-complex-table>>.

.Somewhat complex table
[#somewhat-complex-table,cols="1,1,3"]
|===
|Port |Size per channel in bits |Description

|`Mout_oe_ram`
|stem:[1]
|Set to 1 to read from the channel.

|`Mout_we_ram`
|stem:[1]
|Set to 1 to write to the channel.

|`Mout_data_ram_size`
|stem:[log_2("dataWidth") + 1]
|Set the width of bits that should be written to the memory. It can be a value between 0 and the width of your data.

|`Mout_addr_ram`
|stem:["addressWidth"]
|Select the address this channel should operate on.

|`M_Wdata_ram`
|stem:["dataWidth"]
|Contains the data that will be written to memory if `Mout_we_ram` is set.

|`M_Rdata_ram`
|stem:["dataWidth"]
|Contains the data that was read from memory if `Mout_oe_ram` was set in the last cycle.

|`M_DataRdy`
|stem:[1]
|Nonzero if the memory is not ready.

|===

== Referencing other parts of the document

Asciidoc supports referencing other parts of the document. To reference other parts of the document, you can use the `<<id>>` syntax. The template styles them like this:
<<somewhat-complex-table>> and <<short-verilog-listing>> and <<sample-wavedrom-chart>> and <<_using_figures>> and <<invalid-reference>>

== Using abbreviations

When you first use abbreviations you should introduce them like: field-programmable gate array (FPGA). You should also add them to the <<_list_of_abbreviations>>. Every abbreviation added to that list will automatically be linked when it is used in the document. 

For example we can just use FPGA, HLS, RAII and LLVM IR in any sentence and they will be linked without any special markup.

I also recommend adding a link to a more detailed web source like wikipedia to every entry in the list of abbreviations. I usually have the list of abbreviations as the first section after the main content.

To see an example for a list of abbreviations, look at the source for <<_list_of_abbreviations>>.

== Citations and bibliography

This template uses the built-in bibliography support of asciidoctor. It is relativly basic, but I found it to work really well in practice. The Readme goes into more detail how you can structure your bibliography, alternativly you can directly look into the source of this document.

To cite a source just reference it like a figure, table or section. References to sources should grammatically not be a part of your sentence.

.Example
The Rust programming language <<Kla23>> is a modern systems programming language. It is the most loved programming languag of the last years <<Sta16>> <<Sta20>> <<Sta23>>. On an unrelated note, Microsoft uses FPGAs to accelerate their Bing search engine <<Nan16>> and bambu <<Fer21>> is a framework for HLS. I dont think Microsoft uses bambu for their FPGAs, they probably use the SystemVerilog, the most common language for hardware design <<Soz22>>.

== Future work


// How can the Rust compiler be made to generate better LLVM IR for HLS?

// Measure more test cases

// Test out the limitations of the toolchain

// 



// Can it be better than CPP when the tools are adjusted for Rust LLVM?
Future work on HLS from Rust should focus on improving support for Rust-generated LLVM IR in HLS tools. While Bambu can currently synthesize the LLVM IR generated by Rust, it seems possible to improve the generated designs in some cases. Finding these cases and improving Bambu to handle them should be possible.

It would also be interesting to see if the LLVM IR generated by Rust can be improved to generate better designs. Our toolchain builds every project dependency separately and then links them together. This is not ideal, as it does not allow the compiler to perform cross-crate link-time optimizations. This would probably require adjusting cargo or the Rust compiler to allow link-time optimizations when compiling to LLVM IR. The toolchain only configures the Rust compiler with the settings necessary for generating LLVM IR that Bambu can synthesize. Besides that, it uses rustc's default optimization profiles for speed and size. There are probably significant improvements possible by evaluating which optimizations are useful for HLS and which are not.


[glossary]
== List of abbreviations
// Abbreviations from here will automatically be linked to the document

// Abbreviations in random order and links to read more about them
[glossary]
[[FPGA]]FPGA:: Field-Programmable Gate Array link:pass:[https://en.wikipedia.org/wiki/Field-programmable_gate_array][üîó^]
[[HLS]]HLS:: High-Level Synthesis link:pass:[https://en.wikipedia.org/wiki/High-level_synthesis][üîó^]
[[LLVM_IR]]LLVM IR:: LLVM Intermediate Representation link:pass:[https://en.wikipedia.org/wiki/LLVM#Intermediate_representation][üîó^]
[[RAII]]RAII:: Resource Acquisition Is Initialization / Scope-Bound Resource Management link:pass:[https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization][üîó^]

[bibliography]
== References

// Citation style:
// Line 1: All authors full first and last names. Authors seperated by commas.
// Line 2: Title in italics.
// Line 3: Journal/Conference name or any other information about what gives the source credibility.
// Line 4: doi with attached hyperlink. For digital editions, also link the PDF with a üìÅ icon
// +Authors seperated by commas+

// Multiple HLS tools use LLVM
// C/Cpp are the most popular languages for HLS
// NOTE: I focused on FPGA descriptions
// Clock frequency scaling in CPU stalled around 2005
// A alternative approach for high-throughput and energy-efficient processing is to use specific accelerators
// Specialized accelerators are hard to design and program
// RTL requires advanced hardware expertise
// RTL specifies cycle-by-cycle behavior explicitly
// RTL is a low-level abstraction
// RTL leads to longer development times
// FPGAs with HLS can reduce that.
// FPGAs are configurable integrated circuits
// Most FPGAs are reconfigurable
// FPGA vendors provide toolchains to synthesize HTL to bitstream
// bitstream gets programmed to the FPGA
// HLS tools start from an HLL and automatically produce a circuit specification in RTL
// HLS offers to enable software engineers to benefit from the performance and energy efficiency of hardware without having hardware expertise
// HLS tools enable hardware engineers to design systems faster
// HLS tools enable hardware engineers to explore the design space rapidly
// Microsoft uses FPGAs to accelerate Bing search
* [[[Nan16]]]
+Razvan Nane, Vlad-Mihai Sima, Christian Pilato, Jongsok Choi, Blair Fort, Andrew Canis, Yu Ting Chen, Hsuan Hsiao, Stephen Brown, Fabrizio Ferrandi, Jason Anderson, Koen Bertels+ +
_A Survey and Evaluation of FPGA High-Level Synthesis Tools_ +
IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems +
link:pass:[https://doi.org/10.1109/tcad.2015.2513673][10.1109/tcad.2015.2513673^]
link:pass:[https://sci-hub.st/10.1109/tcad.2015.2513673][üìÅ^]

// Bambu provides a research environment to experiment with new ideas across HLS, high-level verification, and debugging.
// Bambu input: standard C/{cpp} specifications, LLVM IR, IRs from GCC
// Includes many optimizations
// Makes it easy to integrate new transformations and optimizations
// Is open-source
// Bambu is a command line tool
// Supports most C/{cpp} constructs
// Bambu has three phases. frontend, middleend and backend
// Frontend: Uses Clang or gcc
// Uses a compiler plugin for both extracting the call graph and control flow information
// Builds its own static single assignment IR
// This decouples the compiler front end from the rest of the HLS process.
// Vivado HLS has a frontend based on Clang
* [[[Fer21]]]
+Fabrizio Ferrandi, Vito Giovanni Castellana, Serena Curzel, Pietro Fezzardi, Michele Fiorito, Marco Lattuada, Marco Minutoli, Christian Pilato, Antonino Tumeo+ +
_Invited: Bambu: an Open-Source Research Framework for the High-Level Synthesis of Complex Applications_ +
ACM/IEEE Design Automation Conference +
link:pass:[https://doi.org/10.1109/DAC18074.2021.9586110][10.1109/DAC18074.2021.9586110^]
link:pass:[https://re.public.polimi.it/retrieve/668507/dac21_bambu.pdf][üìÅ^]

// SystemVerilog is the de facto standard for RTL design
* [[[Soz22]]]
+Emanuele Del Sozzo, Davide Conficconi, Alberto Zeni, Mirko Salaris, Donatella Sciuto, Marco D. Santambrogio+ +
_Pushing the level of abstraction of digital system design: A survey on how to program FPGAs_ +
ACM Computing Surveys +
link:pass:[https://doi.org/10.1145/3532989][10.1145/3532989^]
link:pass:[https://re.public.polimi.it/retrieve/e3b8d0bb-125b-4457-9780-250f72ef7a02/Survey_FPGA_CSUR.pdf][üìÅ^]

// Rust is the most loved language of 2016
* [[[Sta16]]]
+Stack Overflow+ +
_Stack Overflow Developer Survey 2016_ +
[Online; accessed 5.7.23] +
link:pass:[https://insights.stackoverflow.com/survey/2016/][insights.stackoverflow.com/survey/2016^]

// Rust is the most loved language of 2020
* [[[Sta20]]]
+Stack Overflow+ +
_Stack Overflow Developer Survey 2020_ +
[Online; accessed 5.7.23] +
link:pass:[https://insights.stackoverflow.com/survey/2020/][insights.stackoverflow.com/survey/2020^]

// Rust is the most loved language of 2023
* [[[Sta23]]]
+Stack Overflow+ +
_Stack Overflow Developer Survey 2023_ +
[Online; accessed 5.7.23] +
link:pass:[https://survey.stackoverflow.co/2023/][survey.stackoverflow.co/2023^]

* [[[Kla23]]]
+Steve Klabnik, Carol Nichols+ +
_The Rust programming language_ +
[Online; accessed 5.7.23] +
link:pass:[https://doc.rust-lang.org/stable/book/][doc.rust-lang.org/stable/book^]

== Appendix



.Example of a generated RustHDL struct
[source#rust-hls-synthesized-listing.linenums.hundred_max,rust]
----
/// This file was generated by rust_hls. Please do not edit it manually.
/// rust_hls hash: "fc1b10f200f5632694995e666ba00202"

extern crate verilated;
use ::rust_hdl::prelude::*;

#[allow(dead_code, unused)]
mod minmax_verilated {
    /// Bindings to the C++ library generated by Verilator go here
}

#[derive(::std::default::Default)]
pub struct Minmax {
    pub clk: Signal<
        In,
        Clock,
    >,
    pub reset: Signal<In, bool>,
    pub start_port: Signal<In, bool>,
    pub elements: Signal<In,Bits<32usize>>,
    pub num_elements: Signal<In,Bits<32usize>>,
    pub m_rdata_ram: Signal<In,Bits<32usize>>,
    pub m_data_rdy: Signal<In, bool>,
    pub done_port: Signal<Out, bool>,
    pub return_port: Signal<Out,Bits<64usize>,>,
    pub mout_oe_ram: Signal<Out, bool>,
    pub mout_we_ram: Signal<Out, bool>,
    pub mout_addr_ram: Signal<Out,Bits<32usize>>,
    pub mout_wdata_ram: Signal<Out,Bits<32usize>>,
    pub mout_data_ram_size: Signal<Out,Bits<6usize>>,
    verilated_module: Arc<Mutex<self::minmax_verilated::MinmaxVerilated>>,
}
unsafe impl Send for Minmax {}

#[automatically_derived]
impl Logic for Minmax {
    fn update(&mut self) {
        let mut verilated_module = match self.verilated_module.lock() {
            Ok(verilated_module) => verilated_module,
            Err(e) => panic!("Failed to aquire verilated_module lock: {}", e),
        };
        verilated_module.set_clk(if self.clk.val().clk { 1u8 } else { 0u8 });
        verilated_module.set_reset(if self.reset.val() { 1u8 } else { 0u8 });
        verilated_module.set_start_port(if self.start_port.val() { 1u8 } else { 0u8 });
        verilated_module.set_Pd61(self.elements.val().to_u32());
        verilated_module.set_Pd62(self.num_elements.val().to_u32());
        verilated_module.set_M_Rdata_ram(self.m_rdata_ram.val().to_u32());
        verilated_module.set_M_DataRdy(if self.m_data_rdy.val() { 1u8 } else { 0u8 });
        verilated_module.eval();
        self.done_port.next = verilated_module.done_port() != 0;
        self
            .return_port
            .next = to_bits::<
            64usize,
        >(verilated_module.return_port() & 18446744073709551615u64);
        self.mout_oe_ram.next = verilated_module.Mout_oe_ram() != 0;
        self.mout_we_ram.next = verilated_module.Mout_we_ram() != 0;
        self.mout_addr_ram.next = to_bits::<32usize,>(
          verilated_module.Mout_addr_ram() & 4294967295u32);
        self.mout_wdata_ram.next = to_bits::<32usize,>(
          verilated_module.Mout_Wdata_ram() & 4294967295u32);
        self.mout_data_ram_size.next = to_bits::<6usize,>(
          verilated_module.Mout_data_ram_size() & 63u8);
    }
    fn connect(&mut self) {
        self.done_port.connect();
        self.return_port.connect();
        self.mout_oe_ram.connect();
        self.mout_we_ram.connect();
        self.mout_addr_ram.connect();
        self.mout_wdata_ram.connect();
        self.mout_data_ram_size.connect();
    }
    fn hdl(&self) -> Verilog {
        Verilog::Wrapper(Wrapper {
            code: r#"minmax minmax_inst(
                      .clk(clk), .reset(reset), .start_port(start_port),
                      .done_port(done_port), .return_port(return_port),
                      .Pd61(elements), .Pd62(num_elements),
                      .M_Rdata_ram(m_rdata_ram), .M_DataRdy(m_data_rdy),
                      .Mout_oe_ram(mout_oe_ram), .Mout_we_ram(mout_we_ram),
                      .Mout_addr_ram(mout_addr_ram), .Mout_Wdata_ram(mout_wdata_ram),
                      .Mout_data_ram_size(mout_data_ram_size));"#
                .into(),
            cores: "verilog generated by bambu ...",
        })
    }
}
----


// Reference thesis:
// * https://webthesis.biblio.polito.it/7573/1/tesi.pdf
// * https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1754&context=theses

include::scripts/trailing-scripts.adoc[]


// Final checklist:
// * are all abbreviations defined?
// * are all abbreviations linked to Wikipedia (or somewhere else)?
// * are all references used?
// * are all references linked to the correct source?
// * are all TODOs processed?
// * are the product names consistent? (Bambu)
// * check for duplicate references
// * check for broken references
// * archive.org all links
// * Check for duplication of information
// * oxford comma
// * style code blocks